{"ast":null,"code":"/*\n\tcompiles a selector to an executable function\n*/\nmodule.exports = compile;\nmodule.exports.compileUnsafe = compileUnsafe;\n\nvar parse = require(\"css-what\"),\n    DomUtils = require(\"domutils\"),\n    isTag = DomUtils.isTag,\n    Rules = require(\"./general.js\"),\n    sortRules = require(\"./sort.js\"),\n    BaseFuncs = require(\"boolbase\"),\n    trueFunc = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc,\n    procedure = require(\"./procedure.json\");\n\nfunction compile(selector, options) {\n  var next = compileUnsafe(selector, options);\n  return wrap(next);\n}\n\nfunction wrap(next) {\n  return function base(elem) {\n    return isTag(elem) && next(elem);\n  };\n}\n\nfunction compileUnsafe(selector, options) {\n  var token = parse(selector, options);\n  return compileToken(token, options);\n}\n\nfunction compileToken(token, options) {\n  token.forEach(sortRules);\n\n  if (options && options.context) {\n    var ctx = options.context;\n    token.forEach(function (t) {\n      if (!isTraversal(t[0])) {\n        t.unshift({\n          type: \"descendant\"\n        });\n      }\n    });\n    var context = Array.isArray(ctx) ? function (elem) {\n      return ctx.indexOf(elem) >= 0;\n    } : function (elem) {\n      return ctx === elem;\n    };\n\n    if (options.rootFunc) {\n      var root = options.rootFunc;\n\n      options.rootFunc = function (elem) {\n        return context(elem) && root(elem);\n      };\n    } else {\n      options.rootFunc = context;\n    }\n  }\n\n  return token.map(compileRules, options).reduce(reduceRules, falseFunc);\n}\n\nfunction isTraversal(t) {\n  return procedure[t.type] < 0;\n}\n\nfunction compileRules(rules) {\n  if (rules.length === 0) return falseFunc;\n  var options = this;\n  return rules.reduce(function (func, rule) {\n    if (func === falseFunc) return func;\n    return Rules[rule.type](func, rule, options);\n  }, options && options.rootFunc || trueFunc);\n}\n\nfunction reduceRules(a, b) {\n  if (b === falseFunc || a === trueFunc) {\n    return a;\n  }\n\n  if (a === falseFunc || b === trueFunc) {\n    return b;\n  }\n\n  return function combine(elem) {\n    return a(elem) || b(elem);\n  };\n} //:not, :has and :matches have to compile selectors\n//doing this in lib/pseudos.js would lead to circular dependencies,\n//so we add them here\n\n\nvar Pseudos = require(\"./pseudos.js\"),\n    filters = Pseudos.filters,\n    existsOne = DomUtils.existsOne,\n    isTag = DomUtils.isTag,\n    getChildren = DomUtils.getChildren;\n\nfunction containsTraversal(t) {\n  return t.some(isTraversal);\n}\n\nfunction stripQuotes(str) {\n  var firstChar = str.charAt(0);\n\n  if (firstChar === str.slice(-1) && (firstChar === \"'\" || firstChar === \"\\\"\")) {\n    str = str.slice(1, -1);\n  }\n\n  return str;\n}\n\nfilters.not = function (next, select, options) {\n  var func,\n      opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict)\n  };\n  select = stripQuotes(select);\n\n  if (opts.strict) {\n    var tokens = parse(select);\n\n    if (tokens.length > 1 || tokens.some(containsTraversal)) {\n      throw new SyntaxError(\"complex selectors in :not aren't allowed in strict mode\");\n    }\n\n    func = compileToken(tokens, opts);\n  } else {\n    func = compileUnsafe(select, opts);\n  }\n\n  if (func === falseFunc) return next;\n  if (func === trueFunc) return falseFunc;\n  return function (elem) {\n    return !func(elem) && next(elem);\n  };\n};\n\nfilters.has = function (next, selector, options) {\n  //TODO add a dynamic context in front of every selector with a traversal\n  //:has will never be reached with options.strict == true\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict)\n  };\n  var func = compileUnsafe(selector, opts);\n  if (func === falseFunc) return falseFunc;\n  if (func === trueFunc) return function (elem) {\n    return getChildren(elem).some(isTag) && next(elem);\n  };\n  func = wrap(func);\n  return function has(elem) {\n    return next(elem) && existsOne(func, getChildren(elem));\n  };\n};\n\nfilters.matches = function (next, selector, options) {\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict),\n    rootFunc: next\n  };\n  selector = stripQuotes(selector);\n  return compileUnsafe(selector, opts);\n};","map":null,"metadata":{},"sourceType":"script"}
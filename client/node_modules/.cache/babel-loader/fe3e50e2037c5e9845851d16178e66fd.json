{"ast":null,"code":"/**\n * DEBUG=nightmare*\n */\nvar log = require('debug')('nightmare:log');\n\nvar debug = require('debug')('nightmare');\n\nvar electronLog = {\n  stdout: require('debug')('electron:stdout'),\n  stderr: require('debug')('electron:stderr')\n};\n/**\n * Module dependencies\n */\n\nvar default_electron_path = require('electron');\n\nvar source = require('function-source');\n\nvar proc = require('child_process');\n\nvar actions = require('./actions');\n\nvar path = require('path');\n\nvar sliced = require('sliced');\n\nvar child = require('./ipc');\n\nvar once = require('once');\n\nvar split2 = require('split2');\n\nvar defaults = require('defaults');\n\nvar noop = function noop() {};\n\nvar keys = Object.keys; // Standard timeout for loading URLs\n\nvar DEFAULT_GOTO_TIMEOUT = 30 * 1000; // Standard timeout for wait(ms)\n\nvar DEFAULT_WAIT_TIMEOUT = 30 * 1000; // Timeout between keystrokes for `.type()`\n\nvar DEFAULT_TYPE_INTERVAL = 100; // timeout between `wait` polls\n\nvar DEFAULT_POLL_INTERVAL = 250; // max retry for authentication\n\nvar MAX_AUTH_RETRIES = 3; // max execution time for `.evaluate()`\n\nvar DEFAULT_EXECUTION_TIMEOUT = 30 * 1000; // Error message when halted\n\nvar DEFAULT_HALT_MESSAGE = 'Nightmare Halted'; // Non-persistent partition to use by defaults\n\nvar DEFAULT_PARTITION = 'nightmare';\n/**\n * Export `Nightmare`\n */\n\nmodule.exports = Nightmare;\n/**\n * runner script\n */\n\nvar runner = path.join(__dirname, 'runner.js');\n/**\n * Template\n */\n\nvar template = require('./javascript');\n/**\n * Initialize `Nightmare`\n *\n * @param {Object} options\n */\n\n\nfunction Nightmare(options) {\n  var _this = this;\n\n  if (!(this instanceof Nightmare)) return new Nightmare(options);\n  options = options || {};\n  var electronArgs = {};\n  var self = this;\n  options.waitTimeout = options.waitTimeout || DEFAULT_WAIT_TIMEOUT;\n  options.gotoTimeout = options.gotoTimeout || DEFAULT_GOTO_TIMEOUT;\n  options.pollInterval = options.pollInterval || DEFAULT_POLL_INTERVAL;\n  options.typeInterval = options.typeInterval || DEFAULT_TYPE_INTERVAL;\n  options.executionTimeout = options.executionTimeout || DEFAULT_EXECUTION_TIMEOUT;\n  options.webPreferences = options.webPreferences || {}; // null is a valid value, which will result in the use of the electron default behavior, which is to persist storage.\n  // The default behavior for nightmare will be to use non-persistent storage.\n  // http://electron.atom.io/docs/api/browser-window/#new-browserwindowoptions\n\n  options.webPreferences.partition = options.webPreferences.partition !== undefined ? options.webPreferences.partition : DEFAULT_PARTITION;\n  options.Promise = options.Promise || Nightmare.Promise || Promise;\n  var electron_path = options.electronPath || default_electron_path;\n\n  if (options.paths) {\n    electronArgs.paths = options.paths;\n  }\n\n  if (options.switches) {\n    electronArgs.switches = options.switches;\n  }\n\n  options.maxAuthRetries = options.maxAuthRetries || MAX_AUTH_RETRIES;\n  electronArgs.loadTimeout = options.loadTimeout;\n\n  if (options.loadTimeout && options.gotoTimeout && options.loadTimeout < options.gotoTimeout) {\n    debug(\"WARNING:  load timeout of \".concat(options.loadTimeout, \" is shorter than goto timeout of \").concat(options.gotoTimeout));\n  }\n\n  electronArgs.dock = options.dock || false;\n  attachToProcess(this); // initial state\n\n  this.state = 'initial';\n  this.running = false;\n  this.ending = false;\n  this.ended = false;\n  this._queue = [];\n  this._headers = {};\n  this.options = options;\n  debug('queuing process start');\n  this.queue(function (done) {\n    _this.proc = proc.spawn(electron_path, [runner].concat(JSON.stringify(electronArgs)), {\n      stdio: [null, null, null, 'ipc'],\n      env: defaults(options.env || {}, process.env)\n    });\n\n    _this.proc.stdout.pipe(split2()).on('data', function (data) {\n      electronLog.stdout(data);\n    });\n\n    _this.proc.stderr.pipe(split2()).on('data', function (data) {\n      electronLog.stderr(data);\n    });\n\n    _this.proc.on('close', function (code) {\n      if (!self.ended) {\n        handleExit(code, self, noop);\n      }\n    });\n\n    _this.child = child(_this.proc);\n\n    _this.child.once('die', function (err) {\n      debug('dying: ' + err);\n      self.die = err;\n    }); // propagate console.log(...) through\n\n\n    _this.child.on('log', function () {\n      log.apply(log, arguments);\n    });\n\n    _this.child.on('uncaughtException', function (stack) {\n      console.error('Nightmare runner error:\\n\\n%s\\n', '\\t' + stack.replace(/\\n/g, '\\n\\t'));\n      endInstance(self, noop);\n      process.exit(1);\n    });\n\n    _this.child.on('page', function (type) {\n      log.apply(null, ['page-' + type].concat(sliced(arguments, 1)));\n    }); // propogate events through to debugging\n\n\n    _this.child.on('did-finish-load', function () {\n      log('did-finish-load', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-fail-load', function () {\n      log('did-fail-load', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-fail-provisional-load', function () {\n      log('did-fail-provisional-load', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-frame-finish-load', function () {\n      log('did-frame-finish-load', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-start-loading', function () {\n      log('did-start-loading', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-stop-loading', function () {\n      log('did-stop-loading', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-get-response-details', function () {\n      log('did-get-response-details', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('did-get-redirect-request', function () {\n      log('did-get-redirect-request', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('dom-ready', function () {\n      log('dom-ready', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('page-favicon-updated', function () {\n      log('page-favicon-updated', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('new-window', function () {\n      log('new-window', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('will-navigate', function () {\n      log('will-navigate', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('crashed', function () {\n      log('crashed', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('plugin-crashed', function () {\n      log('plugin-crashed', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('destroyed', function () {\n      log('destroyed', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('media-started-playing', function () {\n      log('media-started-playing', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.on('media-paused', function () {\n      log('media-paused', JSON.stringify(Array.prototype.slice.call(arguments)));\n    });\n\n    _this.child.once('ready', function (versions) {\n      _this.engineVersions = versions;\n\n      _this.child.call('browser-initialize', options, function () {\n        self.state = 'ready';\n        done();\n      });\n    });\n  }); // initialize namespaces\n\n  Nightmare.namespaces.forEach(function (name) {\n    if ('function' === typeof this[name]) {\n      this[name] = this[name]();\n    }\n  }, this); //prepend adding child actions to the queue\n\n  Object.keys(Nightmare.childActions).forEach(function (key) {\n    debug('queueing child action addition for \"%s\"', key);\n    this.queue(function (done) {\n      this.child.call('action', key, String(Nightmare.childActions[key]), done);\n    });\n  }, this);\n}\n\nfunction handleExit(code, instance, cb) {\n  var help = {\n    127: 'command not found - you may not have electron installed correctly',\n    126: 'permission problem or command is not an executable - you may not have all the necessary dependencies for electron',\n    1: 'general error - you may need xvfb',\n    0: 'success!'\n  };\n  debug('electron child process exited with code ' + code + ': ' + help[code]);\n  instance.proc.removeAllListeners();\n  cb();\n}\n\n;\n\nfunction endInstance(instance, cb, forceKill) {\n  instance.ended = true;\n  detachFromProcess(instance);\n\n  if (instance.proc && instance.proc.connected) {\n    instance.proc.on('close', function (code) {\n      handleExit(code, instance, cb);\n    });\n    instance.child.call('quit', function () {\n      instance.child.removeAllListeners();\n\n      if (forceKill) {\n        instance.proc.kill('SIGINT');\n      }\n    });\n  } else {\n    debug('electron child process not started yet, skipping kill.');\n    cb();\n  }\n}\n/**\n * Attach any instance-specific process-level events.\n */\n\n\nfunction attachToProcess(instance) {\n  instance._endNow = endInstance.bind(null, instance, noop);\n  process.setMaxListeners(Infinity);\n  process.on('exit', instance._endNow);\n  process.on('SIGINT', instance._endNow);\n  process.on('SIGTERM', instance._endNow);\n  process.on('SIGQUIT', instance._endNow);\n  process.on('SIGHUP', instance._endNow);\n  process.on('SIGBREAK', instance._endNow);\n}\n\nfunction detachFromProcess(instance) {\n  process.removeListener('exit', instance._endNow);\n  process.removeListener('SIGINT', instance._endNow);\n  process.removeListener('SIGTERM', instance._endNow);\n  process.removeListener('SIGQUIT', instance._endNow);\n  process.removeListener('SIGHUP', instance._endNow);\n  process.removeListener('SIGBREAK', instance._endNow);\n}\n/**\n * Namespaces to initialize\n */\n\n\nNightmare.namespaces = [];\n/**\n * Child actions to create\n */\n\nNightmare.childActions = {};\n/**\n * Version\n */\n\nNightmare.version = require(path.resolve(__dirname, '..', 'package.json')).version;\n/**\n * Promise library (can override)\n */\n\nNightmare.Promise = Promise;\n/**\n * Override headers for all HTTP requests\n */\n\nNightmare.prototype.header = function (header, value) {\n  if (header && typeof value !== 'undefined') {\n    this._headers[header] = value;\n  } else {\n    this._headers = header || {};\n  }\n\n  return this;\n};\n/**\n * Go to a `url`\n */\n\n\nNightmare.prototype.goto = function (url, headers) {\n  debug('queueing action \"goto\" for %s', url);\n  var self = this;\n  headers = headers || {};\n\n  for (var key in this._headers) {\n    headers[key] = headers[key] || this._headers[key];\n  }\n\n  this.queue(function (fn) {\n    self.child.call('goto', url, headers, this.options.gotoTimeout, fn);\n  });\n  return this;\n};\n/**\n * run\n */\n\n\nNightmare.prototype.run = function (fn) {\n  debug('running');\n  var steps = this.queue();\n  this.running = true;\n  this._queue = [];\n  var self = this; // kick us off\n\n  next(); // next function\n\n  function next(err, res) {\n    var item = steps.shift(); // Immediately halt execution if an error has been thrown, or we have no more queued up steps.\n\n    if (err || !item) return done.apply(self, arguments);\n    var args = item[1] || [];\n    var method = item[0];\n    args.push(once(after));\n    method.apply(self, args);\n  }\n\n  function after(err, res) {\n    err = err || self.die;\n    var args = sliced(arguments);\n\n    if (self.child) {\n      self.child.call('continue', function () {\n        return next.apply(self, args);\n      });\n    } else {\n      next.apply(self, args);\n    }\n  }\n\n  function done() {\n    var doneargs = arguments;\n    self.running = false;\n\n    if (self.ending) {\n      return endInstance(self, function () {\n        return fn.apply(self, doneargs);\n      });\n    }\n\n    return fn.apply(self, doneargs);\n  }\n\n  return this;\n};\n/**\n * run the code now (do not queue it)\n *\n * you should not use this, unless you know what you're doing\n * it should be used for plugins and custom actions, not for\n * normal API usage\n */\n\n\nNightmare.prototype.evaluate_now = function (js_fn, done) {\n  var args = Array.prototype.slice.call(arguments).slice(2).map(function (a) {\n    return {\n      argument: JSON.stringify(a)\n    };\n  });\n  var source = template.execute({\n    src: String(js_fn),\n    args: args\n  });\n  this.child.call('javascript', source, done);\n  return this;\n};\n/**\n * inject javascript\n */\n\n\nNightmare.prototype._inject = function (js, done) {\n  this.child.call('javascript', template.inject({\n    src: js\n  }), done);\n  return this;\n};\n/**\n * end\n */\n\n\nNightmare.prototype.end = function (done) {\n  this.ending = true;\n\n  if (done && !this.running && !this.ended) {\n    return this.then(done);\n  }\n\n  return this;\n};\n/**\n * Halt - Force kills the electron process immediately and empties the queue\n *\n * @param  {Error|String} error (Optional: defaults to 'Nightmare Halted'.) Error to pass to rejected promise\n * @param  {Function} done (Optional: defaults to no operation) callback when the child process exits\n * @return {Nightmare}       returns self\n */\n\n\nNightmare.prototype.halt = function (error, done) {\n  this.ending = true;\n  var queue = this.queue(); // empty the queue\n\n  queue.splice(0);\n\n  if (!this.ended) {\n    var message = error;\n\n    if (error instanceof Error) {\n      message = error.message;\n    }\n\n    this.die = message || DEFAULT_HALT_MESSAGE;\n\n    if (typeof this._rejectActivePromise === 'function') {\n      this._rejectActivePromise(error || DEFAULT_HALT_MESSAGE);\n    }\n\n    var callback = done;\n\n    if (!callback || typeof callback !== 'function') {\n      callback = noop;\n    }\n\n    endInstance(this, callback, true);\n  }\n\n  return this;\n};\n/**\n * on\n */\n\n\nNightmare.prototype.on = function (event, handler) {\n  this.queue(function (done) {\n    this.child.on(event, handler);\n    done();\n  });\n  return this;\n};\n/**\n * once\n */\n\n\nNightmare.prototype.once = function (event, handler) {\n  this.queue(function (done) {\n    this.child.once(event, handler);\n    done();\n  });\n  return this;\n};\n/**\n * removeEventListener\n */\n\n\nNightmare.prototype.removeListener = function (event, handler) {\n  this.child.removeListener(event, handler);\n  return this;\n};\n/**\n * Queue\n */\n\n\nNightmare.prototype.queue = function (done) {\n  if (!arguments.length) return this._queue;\n  var args = sliced(arguments);\n  var fn = args.pop();\n\n  this._queue.push([fn, args]);\n};\n/**\n * then\n */\n\n\nNightmare.prototype.then = function (fulfill, reject) {\n  var self = this;\n  return new this.options.Promise(function (success, failure) {\n    self._rejectActivePromise = failure;\n    self.run(function (err, result) {\n      if (err) failure(err);else success(result);\n    });\n  }).then(fulfill, reject);\n};\n/**\n * catch\n */\n\n\nNightmare.prototype.catch = function (reject) {\n  this._rejectActivePromise = reject;\n  return this.then(undefined, reject);\n};\n/**\n * use\n */\n\n\nNightmare.prototype.use = function (fn) {\n  fn(this);\n  return this;\n}; // wrap all the functions in the queueing function\n\n\nfunction queued(name, fn) {\n  return function action() {\n    debug('queueing action \"' + name + '\"');\n    var args = [].slice.call(arguments);\n\n    this._queue.push([fn, args]);\n\n    return this;\n  };\n}\n/**\n * Static: Support attaching custom actions\n *\n * @param {String} name - method name\n * @param {Function|Object} [childfn] - Electron implementation\n * @param {Function|Object} parentfn - Nightmare implementation\n * @return {Nightmare}\n */\n\n\nNightmare.action = function () {\n  var name = arguments[0],\n      childfn,\n      parentfn;\n\n  if (arguments.length === 2) {\n    parentfn = arguments[1];\n  } else {\n    parentfn = arguments[2];\n    childfn = arguments[1];\n  } // support functions and objects\n  // if it's an object, wrap it's\n  // properties in the queue function\n\n\n  if (parentfn) {\n    if (typeof parentfn === 'function') {\n      Nightmare.prototype[name] = queued(name, parentfn);\n    } else {\n      if (!~Nightmare.namespaces.indexOf(name)) {\n        Nightmare.namespaces.push(name);\n      }\n\n      Nightmare.prototype[name] = function () {\n        var self = this;\n        return keys(parentfn).reduce(function (obj, key) {\n          obj[key] = queued(name, parentfn[key]).bind(self);\n          return obj;\n        }, {});\n      };\n    }\n  }\n\n  if (childfn) {\n    if (typeof childfn === 'function') {\n      Nightmare.childActions[name] = childfn;\n    } else {\n      for (var key in childfn) {\n        Nightmare.childActions[name + '.' + key] = childfn;\n      }\n    }\n  }\n};\n/**\n * Attach all the actions.\n */\n\n\nObject.keys(actions).forEach(function (name) {\n  var fn = actions[name];\n  Nightmare.action(name, fn);\n});","map":null,"metadata":{},"sourceType":"script"}
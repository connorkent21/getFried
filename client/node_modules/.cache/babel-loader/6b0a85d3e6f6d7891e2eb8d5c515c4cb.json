{"ast":null,"code":"\"use strict\";\n\nmodule.exports = parse;\nvar re_ws = /^\\s/,\n    re_name = /^(?:\\\\.|[\\w\\-\\u00c0-\\uFFFF])+/,\n    re_escape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/ig,\n    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87\nre_attr = /^\\s*((?:\\\\.|[\\w\\u00c0-\\uFFFF\\-])+)\\s*(?:(\\S?)=\\s*(?:(['\"])(.*?)\\3|(#?(?:\\\\.|[\\w\\u00c0-\\uFFFF\\-])*)|)|)\\s*(i)?\\]/;\nvar actionTypes = {\n  __proto__: null,\n  \"undefined\": \"exists\",\n  \"\": \"equals\",\n  \"~\": \"element\",\n  \"^\": \"start\",\n  \"$\": \"end\",\n  \"*\": \"any\",\n  \"!\": \"not\",\n  \"|\": \"hyphen\"\n};\nvar simpleSelectors = {\n  __proto__: null,\n  \">\": \"child\",\n  \"<\": \"parent\",\n  \"~\": \"sibling\",\n  \"+\": \"adjacent\"\n};\nvar attribSelectors = {\n  __proto__: null,\n  \"#\": [\"id\", \"equals\"],\n  \".\": [\"class\", \"element\"]\n}; //unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139\n\nfunction funescape(_, escaped, escapedWhitespace) {\n  var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n  // Support: Firefox\n  // Workaround erroneous numeric interpretation of +\"0x\"\n\n  return high !== high || escapedWhitespace ? escaped : // BMP codepoint\n  high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n}\n\nfunction unescapeCSS(str) {\n  return str.replace(re_escape, funescape);\n}\n\nfunction getClosingPos(selector) {\n  var pos = 1,\n      counter = 1,\n      len = selector.length;\n\n  for (; counter > 0 && pos < len; pos++) {\n    if (selector.charAt(pos) === \"(\") counter++;else if (selector.charAt(pos) === \")\") counter--;\n  }\n\n  return pos;\n}\n\nfunction parse(selector, options) {\n  selector = (selector + \"\").trimLeft();\n  var subselects = [],\n      tokens = [],\n      sawWS = false,\n      data,\n      firstChar,\n      name;\n\n  function getName() {\n    var sub = selector.match(re_name)[0];\n    selector = selector.substr(sub.length);\n    return unescapeCSS(sub);\n  }\n\n  while (selector !== \"\") {\n    if (re_name.test(selector)) {\n      if (sawWS) {\n        tokens.push({\n          type: \"descendant\"\n        });\n        sawWS = false;\n      }\n\n      name = getName();\n\n      if (!options || (\"lowerCaseTags\" in options ? options.lowerCaseTags : !options.xmlMode)) {\n        name = name.toLowerCase();\n      }\n\n      tokens.push({\n        type: \"tag\",\n        name: name\n      });\n    } else if (re_ws.test(selector)) {\n      sawWS = true;\n      selector = selector.trimLeft();\n    } else {\n      firstChar = selector.charAt(0);\n      selector = selector.substr(1);\n\n      if (firstChar in simpleSelectors) {\n        tokens.push({\n          type: simpleSelectors[firstChar]\n        });\n        selector = selector.trimLeft();\n        sawWS = false;\n        continue;\n      } else if (firstChar === \",\") {\n        if (tokens.length === 0) {\n          throw new SyntaxError(\"empty sub-selector\");\n        }\n\n        subselects.push(tokens);\n        tokens = [];\n        selector = selector.trimLeft();\n        sawWS = false;\n        continue;\n      } else if (sawWS) {\n        tokens.push({\n          type: \"descendant\"\n        });\n        sawWS = false;\n      }\n\n      if (firstChar === \"*\") {\n        tokens.push({\n          type: \"universal\"\n        });\n      } else if (firstChar in attribSelectors) {\n        tokens.push({\n          type: \"attribute\",\n          name: attribSelectors[firstChar][0],\n          action: attribSelectors[firstChar][1],\n          value: getName(),\n          ignoreCase: false\n        });\n      } else if (firstChar === \"[\") {\n        data = selector.match(re_attr);\n\n        if (!data) {\n          throw new SyntaxError(\"Malformed attribute selector: \" + selector);\n        }\n\n        selector = selector.substr(data[0].length);\n        name = unescapeCSS(data[1]);\n\n        if (!options || (\"lowerCaseAttributeNames\" in options ? options.lowerCaseAttributeNames : !options.xmlMode)) {\n          name = name.toLowerCase();\n        }\n\n        tokens.push({\n          type: \"attribute\",\n          name: name,\n          action: actionTypes[data[2]],\n          value: unescapeCSS(data[4] || data[5] || \"\"),\n          ignoreCase: !!data[6]\n        });\n      } else if (firstChar === \":\") {\n        //if(selector.charAt(0) === \":\"){} //TODO pseudo-element\n        name = getName().toLowerCase();\n        data = null;\n\n        if (selector.charAt(0) === \"(\") {\n          var pos = getClosingPos(selector);\n          data = selector.substr(1, pos - 2);\n          selector = selector.substr(pos);\n        }\n\n        tokens.push({\n          type: \"pseudo\",\n          name: name,\n          data: data\n        });\n      } else {\n        //otherwise, the parser needs to throw or it would enter an infinite loop\n        throw new SyntaxError(\"Unmatched selector: \" + firstChar + selector);\n      }\n    }\n  }\n\n  if (subselects.length > 0 && tokens.length === 0) {\n    throw new SyntaxError(\"empty sub-selector\");\n  }\n\n  subselects.push(tokens);\n  return subselects;\n}","map":null,"metadata":{},"sourceType":"script"}
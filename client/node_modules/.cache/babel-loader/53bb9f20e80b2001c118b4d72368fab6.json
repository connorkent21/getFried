{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar Emitter = require('events').EventEmitter;\n\nvar sliced = require('sliced');\n\nvar debug = require('debug')('nightmare:ipc'); // If this process has a parent, redirect debug logs to it\n\n\nif (process.send) {\n  debug = function debug() {\n    process.send(['nightmare:ipc:debug'].concat(sliced(arguments)));\n  };\n}\n/**\n * Export `IPC`\n */\n\n\nmodule.exports = IPC;\n/**\n * Initialize `IPC`\n */\n\nvar instance = Symbol();\n\nfunction IPC(process) {\n  if (process[instance]) {\n    return process[instance];\n  }\n\n  var emitter = process[instance] = new Emitter();\n  var emit = emitter.emit;\n  var callId = 0;\n  var responders = {}; // no parent\n\n  if (!process.send) {\n    return emitter;\n  }\n\n  process.on('message', function (data) {\n    // handle debug logging specially\n    if (data[0] === 'nightmare:ipc:debug') {\n      debug.apply(null, sliced(data, 1));\n    }\n\n    emit.apply(emitter, sliced(data));\n  });\n\n  emitter.emit = function () {\n    if (process.connected) {\n      process.send(sliced(arguments));\n    }\n  };\n  /**\n   * Call a responder function in the associated process. (In the process,\n   * responders can be registered with `ipc.respondTo()`.) The last argument\n   * should be a callback function, which will called with the results of the\n   * responder.\n   * This returns an event emitter. You can listen for the results of the\n   * responder using the `end` event (this is the same as passing a callback).\n   * Additionally, you can listen for `data` events, which the responder may\n   * send to indicate some sort of progress.\n   * @param  {String} name Name of the responder function to call\n   * @param  {...Objects} [arguments] Any number of arguments to send\n   * @param  {Function} [callback] A callback function that handles the results\n   * @return {Emitter}\n   */\n\n\n  emitter.call = function (name) {\n    var args = sliced(arguments, 1);\n    var callback = args.pop();\n\n    if (typeof callback !== 'function') {\n      args.push(callback);\n      callback = undefined;\n    }\n\n    var id = callId++;\n    var progress = new Emitter();\n    emitter.on(\"CALL_DATA_\".concat(id), function () {\n      progress.emit.apply(progress, ['data'].concat(sliced(arguments)));\n    });\n    emitter.once(\"CALL_RESULT_\".concat(id), function () {\n      progress.emit.apply(progress, ['end'].concat(sliced(arguments)));\n      emitter.removeAllListeners(\"CALL_DATA_\".concat(id));\n      progress.removeAllListeners();\n      progress = undefined;\n\n      if (callback) {\n        callback.apply(null, arguments);\n      }\n    });\n    emitter.emit.apply(emitter, ['CALL', id, name].concat(args));\n    return progress;\n  };\n  /**\n   * Register a responder to be called from other processes with `ipc.call()`.\n   * The responder should be a function that accepts any number of arguments,\n   * where the last argument is a callback function. When the responder has\n   * finished its work, it MUST call the callback. The first argument should be\n   * an error, if any, and the second should be the results.\n   * Only one responder can be registered for a given name.\n   * @param {String} name The name to register the responder under.\n   * @param {Function} responder\n   */\n\n\n  emitter.respondTo = function (name, responder) {\n    if (responders[name]) {\n      debug(\"Replacing responder named \\\"\".concat(name, \"\\\"\"));\n    }\n\n    responders[name] = responder;\n  };\n\n  emitter.on('CALL', function (id, name) {\n    var args = sliced(arguments, 2);\n    var responder = responders[name];\n\n    var done = function done() {\n      emitter.emit.apply(emitter, [\"CALL_RESULT_\".concat(id)].concat(sliced(arguments)));\n    };\n\n    done.progress = function () {\n      emitter.emit.apply(emitter, [\"CALL_DATA_\".concat(id)].concat(sliced(arguments)));\n    };\n\n    if (!responder) {\n      return done(\"Nothing responds to \\\"\".concat(name, \"\\\"\"));\n    }\n\n    try {\n      responder.apply(null, sliced(arguments, 2).concat([done]));\n    } catch (error) {\n      done(error);\n    }\n  });\n  return emitter;\n}","map":null,"metadata":{},"sourceType":"script"}